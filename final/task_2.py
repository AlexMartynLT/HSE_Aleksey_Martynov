# === НАЧАЛО ФУНКЦИИ ===
def roman_to_int_with_explanation(s):
    """
    Эта функция принимает на вход строку с римским числом (например, "MCMXCIV"),
    а возвращает два значения:
    1. Итоговое десятичное число (например, 1994).
    2. Строку с подробным объяснением, как это число было получено.
    """

    # --- 1. Подготовительный этап ---

    # Создаем "словарь" или "карту" для быстрого доступа к значениям римских цифр.
    # Ключ - это символ (например, 'M'), значение - это его числовой эквивалент (1000).
    roman_map = {
        'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000
    }

    # Инициализируем (создаем) переменную, где будем накапливать итоговый результат.
    # Начинаем с нуля.
    result = 0

    # Создаем пустой список (массив), в который будем складывать части нашего объяснения.
    # В конце он будет выглядеть примерно так: ['M(1000)', 'CM(900)', 'XC(90)', 'IV(4)']
    explanation_parts = []

    # Создаем счетчик 'i', который будет указывать на позицию (индекс) символа в строке,
    # который мы рассматриваем в данный момент. Начинаем с самого первого символа (индекс 0).
    i = 0

    # --- 2. Основной цикл ---

    # Запускаем цикл 'while', который будет работать, пока наш счетчик 'i'
    # не выйдет за пределы строки. 'len(s)' - это длина строки.
    while i < len(s):

        # Получаем числовое значение для ТЕКУЩЕГО символа.
        # s[i] - это сам символ (например, 'M'), roman_map[s[i]] - его значение (1000).
        current_value = roman_map[s[i]]

        # Ключевая проверка: "а есть ли следующий символ?".
        # Мы проверяем, что индекс следующего символа (i + 1) все еще меньше длины строки.
        # Это защищает нас от ошибки, когда мы дойдем до конца.
        if i + 1 < len(s):
            # Если следующий символ есть, получаем и его числовое значение.
            next_value = roman_map[s[i + 1]]

            # Сравниваем значения текущего и следующего символов.
            # Это главный трюк для обработки случаев типа 'IV' (1 и 5) или 'CM' (100 и 1000).
            if current_value < next_value:
                # --- Логика для "хитрых" случаев (IV, IX, XL, XC, CM) ---

                # Прибавляем к результату их разницу (например, 1000 - 100 = 900).
                result += next_value - current_value
                # Формируем красивую строку для объяснения, например "CM(900)", и добавляем в список.
                explanation_parts.append(f'{s[i]}{s[i + 1]}({next_value - current_value})')
                # ВАЖНО: Увеличиваем счетчик на 2, так как мы обработали сразу ДВА символа.
                i += 2
            else:
                # --- Логика для "обычных" случаев (M, V, I, I, I) ---
                # То есть когда следующая цифра меньше или равна текущей.

                # Просто прибавляем значение текущего символа.
                result += current_value
                # Формируем объяснение для одного символа, например "M(1000)".
                explanation_parts.append(f'{s[i]}({current_value})')
                # Увеличиваем счетчик на 1, чтобы перейти к следующему символу.
                i += 1
        else:
            # --- Логика для САМОГО ПОСЛЕДНЕГО символа в строке ---
            # Этот блок кода сработает только один раз, для последней цифры,
            # так как у нее уже нет "следующей".

            result += current_value
            explanation_parts.append(f'{s[i]}({current_value})')
            i += 1

    # --- 3. Завершение и возврат результата ---

    # Теперь, когда цикл закончился, у нас есть список explanation_parts.
    # Мы "склеиваем" все его элементы в одну строку, разделяя их знаком " + ".
    explanation_string = " + ".join(explanation_parts)

    # Функция возвращает два значения: посчитанное число и строку с объяснением.
    return result, explanation_string


# === КОНЕЦ ФУНКЦИИ ===


# === НАЧАЛО ИНТЕРАКТИВНОЙ ЧАСТИ ===
# Этот код находится вне функции и выполняется при запуске файла.

# 1. Запрашиваем у пользователя ввод и сразу переводим его в ВЕРХНИЙ РЕГИСТР
#    с помощью .upper(), чтобы программа одинаково понимала 'mcMxcIv' и 'MCMXCIV'.
user_input = input("Введите римское число: ").upper()

# 2. Проверяем, не ввел ли пользователь пустую строку.
if user_input:
    # Если строка не пустая, вызываем нашу основную функцию.
    # Она возвращает два значения, которые мы сразу "ловим" в две переменные.
    final_number, explanation = roman_to_int_with_explanation(user_input)

    # 3. Печатаем финальный, красивый результат на экран.
    print(f'Ваше число = {user_input}')
    print(f'Значение = {final_number}')
    print(f'Объяснение = {explanation}')
else:
    # Если пользователь ничего не ввел, а просто нажал Enter.
    print("Ошибка: Вы ничего не ввели.")

# === КОНЕЦ ПРОГРАММЫ ===